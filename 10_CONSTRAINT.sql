-- 10_CONSTRAINT.sql

-- 제약조건 : 테이블에 부적절한 자료가 입력되는 것을 방지하기 위해 컬럼마다 정의하는 규칙
-- NOT NULL : NULL을 허용하지 않는다.
-- UNIQUE : 중복값을 허용하지 않는다. 항상 유일한 값을 갖도록 한다.
-- PRIMARY KEY : NOT NULL + UNIQUE. 테이블의 기본키가 된다.
-- FOREIGN KEY : 참조하는 테이블의 특정 컬럼(PK OR UNIQUE)에 존재하는 값만 허용한다.
--                외래키로 참조하려는 컬럼은 반드시 기본키이거나 UNIQUE여야 한다.
-- CHECK    : 직접 원하는 값의 조건을 설정한다.


-- 제약조건 메타데이터 확인
-- USER_CONSTRAINTS 테이블의 CONSTRAINT_TYPE 컬럼의 값에 따라 어떤 제약조건인지 알 수 있다.
 SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='MY_MEMBER';
--      P : PRIMARY KEY
--      R : FOREIGN KEY
--      U : UNIQUE
--      C : NOT NULL, CHECK



SELECT * FROM MY_MEMBER;
DESC MY_MEMBER;


-- 어느 컬럼에 제약조건이 설정되었는지 확인
SELECT * FROM USER_CONS_COLUMNS;    -- ERROR....


-- 이미 존재하는 테이블에 제약조건 추가하기
-- 제약조건을 추가하려는 컬럼에 제약조건을 만족시키지 못하는 행이 존재하면 제약조건을 추가할 수 없다.(이미 조건이 있다.)
-- ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 제약조건 (컬럼);

-- 기본키 제약조건 추가하기
ALTER TABLE MY_MEMBER ADD CONSTRAINT MY_BOARD_MEMNO_PK PRIMARY KEY(MEMNO);

SELECT * FROM MY_MEMBER ORDER BY MEMNO;
SELECT * FROM USER_CONSTRAINTS;
DESC MY_MEMBER;


-- NOT NULL 제약조건 추가하기
-- NOT NULL 제약조건은 ADD CONSTRAINT가 아니라 MODIFY CONSTRAINT를 사용해야 한다.
-- NULL을 허용하는 상태에서 NULL을 허용하지 않ㄴ는 상태로 변경하는 것이기 때문에 MODIFY를 사용한다.

-- ALTER TABLE 테이블명 MODIFY 컬럼명   CONSTRAINT 제약조건명 NOTNULL;
ALTER TABLE MY_MEMBER MODIFY MEM_NAME CONSTRAINT MY_MEMBER_MNAME_NN NOT NULL;

SELECT * FROM USER_CONSTRAINTS; -- 생성된거 확인

-- 아래 두 문장..
INSERT INTO MY_MEMBER(MEMNO, MEM_AGE, JOIN_DATE) VALUES (MY_MEMBER_MEMNO_SEQ.NEXTVAL, 123, SYSDATE); -- 오류 뜨는데????
SELECT * FROM MY_MEMBER ORDER BY MEMNO DESC;


-- 제약조건 제거방법
-- ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명;
-- 기본키 제약조건 제거하기---------------
ALTER TABLE MY_MEMBER DROP CONSTRAINT MY_BOARD_MEMNO_PK;


-- NOTNULL 제약조건 제거하기
ALTER TABLE MY_MEMBER DROP CONSTRAINT MY_MEMBER_MNAME_NN;



-- <외래키 추가하기 실습>
-- EMP02와 DEPT를 생성
DROP TABLE EMP02;   -- 이전에 실습한 테이블 정보 삭제
CREATE TABLE EMP02 AS SELECT * FROM EMP;    -- 복사해서 새로 생성

DROP TABLE DEPT02;  -- 이전에 만들어 놓은 테이블 삭제
CREATE TABLE DEPT02 AS SELECT * FROM DEPT;

SELECT * FROM EMP02;    -- 생성되었는지 확인
SELECT * FROM DEPT02;   -- 확인

-- EMP02에 FK 추가
-- ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 FOREIGN KEY (컬럼명) REFERENCES 참조할테이블명 (컬럼명);
ALTER TABLE EMP02 ADD CONSTRAINT EMP02_DEPTNO_FK FOREIGN KEY (DEPTNO) REFERENCES DEPT02 (DEPTNO);  
-- REFERENCES DEPT02 (DEPTNO) : DEPT02의 DEPTNO 컬럼을 참조한다.

-- FK를 추가하려면 DEPT02의 DEPTNO가 PK 혹은 UNIQUE 여야한다.
ALTER TABLE DEPT02 ADD CONSTRAINT DEPT02_DEPTNO_UNQ UNIQUE(DEPTNO);

SELECT * FROM EMP02 ;

-- FK 제약조건이 걸린 컬럼의 NULL값은 허용하지만 창조하고 있는 곳에 존재하지 않는값은 허용하지 않는다.
INSERT INTO EMP02 VALUES(1, 'TEST', 'TEST', 7792, SYSDATE, 0, NULL, NULL);
INSERT INTO EMP02 VALUES(1, 'TEST', 'TEST', 7792, SYSDATE, 0, NULL, 11);
INSERT INTO EMP02 VALUES(1, 'TEST', 'TEST', 7792, SYSDATE, 0, NULL, 12);


SELECT * FROM MY_MEMBER;
SELECT * FROM USER_CONSTRAINTS;


-- CHECK 제약조건 추가
-- 형식 
-- ALTER TABLE 테이블명 ADD CONSTRAINT 제약조건명 (컬럼명)
ALTER TABLE MY_MEMBER ADD CONSTRAINT MY_MEMBER_AGE_CHK CHECK (MEM_AGE BETWEEN 1 AND 999);

INSERT INTO MY_MEMBER VALUES (MY_MEMBER_MEMNO_SEQ.NEXTVAL, 'TESTER', -5, SYSDATE);  -- 올바른 값이 아님
INSERT INTO MY_MEMBER VALUES (MY_MEMBER_MEMNO_SEQ.NEXTVAL, 'TESTER', 0, SYSDATE);   -- 올바른 값이 아님
INSERT INTO MY_MEMBER VALUES (MY_MEMBER_MEMNO_SEQ.NEXTVAL, 'TESTER', 999.0, SYSDATE); -- 들어가짐

ALTER TABLE MY_MEMBER ADD (GENDER VARCHAR2(1) DEFAULT 'M'); -- 컬럼 생성 , 디폴트 값 M

ALTER TABLE MY_MEMBER DROP COLUMN GENDER;   -- 컬럼 삭제

SELECT * FROM MY_MEMBER;    -- 단순 확인

ALTER TABLE MY_MEMBER ADD CONSTRAINT MY_MEMBER_GENDER_CHK CHECK(GENDER IN ('M','F'));   -- GENDER 컬럼에 제약조건 생성

SELECT * FROM USER_CONSTRAINTS; -- USER_CONSTRAINTS 확인

INSERT INTO MY_MEMBER VALUES (MY_MEMBER_MEMNO_SEQ.NEXTVAL, 'TESTER', 66, SYSDATE, 'F');    -- 목록 추가
INSERT INTO MY_MEMBER VALUES (MY_MEMBER_MEMNO_SEQ.NEXTVAL, 'TESTER', 60, SYSDATE, 'K');  -- 'K'라는 GENDER값이 인정되지 않아서 에러



SELECT * FROM USER_CONSTRAINTS; -- 생선 전에 제약조건 테이블 먼저 확인
-- 테이블 생성과 동시에 제약조건 추가
CREATE TABLE TEST_CONS(
    TNO NUMBER(5) PRIMARY KEY,
    TNAME VARCHAR2(10) NOT NULL,
    GENDER VARCHAR2(1) CHECK(GENDER IN ('M', 'F')),
    JOINDATE DATE DEFAULT SYSDATE 
);
DESC TEST_CONS;
-- 이렇게 테이블과 제약조건을 동시에 생성하면 단점이 있다.
-- 제약조건 이름이 오라클에서 지정해주는 이름이 된다. 매우 불편


-- <실습> 테이블 생성과 동시에 제약조건명과 제약조건 추가
CREATE TABLE TEST_CONS2(
    TNO NUMBER(5) CONSTRAINT CONS2_TNO_PK PRIMARY KEY,
    TNAME VARCHAR2(10) CONSTRAINT CONS2_TNAME_NN NOT NULL,
    GENDER VARCHAR2(1)CONSTRAINT CONS2_GEN_CHK CHECK(GENDER IN ('M', 'F')),
    JOINDATE DATE DEFAULT SYSDATE 
);
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='TEST_CONS2';

--테이블 생성과 동시에  제약조건명과 제약조건 추가2
CREATE TABLE TEST_CONS3(
    TNO NUMBER(5) ,
    TNAME VARCHAR2(10),
    GENDER VARCHAR2(1),
    JOINDATE DATE DEFAULT SYSDATE,
    CONSTRAINT CONS2_TNO_PK PRIMARY KEY(TNO),
    CONSTRAINT CONS2_GEN_CHK CHECK(GENDER IN ('M', 'F'))
);
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='TEST_CONS3';

--<실습> 만들고 있던 테이블에 알맞은 제약조건들을 추가해보세요.
-- NOT NULL, CHECK, PRIMARY KEY, FOREIGN KEY(필요하다면 테이블 추가),  UNIQUE
SELECT * FROM RESTAURANT;
DESC RESTAURANT;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='RESTAURANT';   -- 제약조건 확인하는 명령어


-- NOT NULL 추가하기
ALTER TABLE RESTAURANT MODIFY MENU CONSTRAINT BACK_MENU NOT NULL;   -- 제약조건 생성

INSERT INTO RESTAURANT(RESTAURANT_NO, KIND_OF_FOOD,MENU,PRICE) VALUES(RESTAURANT_NO_SEQ.NEXTVAL, '일식', '초밥', 11000);    -- 제약조건에 기반해 필드 채우기
INSERT INTO RESTAURANT(RESTAURANT_NO, KIND_OF_FOOD,MENU,PRICE) VALUES(RESTAURANT_NO_SEQ.NEXTVAL, '한식', '육회비빔밥', 8000);

SELECT * FROM RESTAURANT ORDER BY RESTAURANT_NO DESC;   -- 생성된 데이터 확인

-- 기본키 제약조건 추가하기
ALTER TABLE MY_MEMBER ADD CONSTRAINT MY_BOARD_MEMNO_PK PRIMARY KEY(MEMNO);  -- 제약조건 추가


-- FOREIGN KEY 추가
CREATE TABLE RES01 AS SELECT * FROM RESTAURANT;
SELECT * FROM RES01;

-- CHECK 추가하기

-- UNIQUE 추가



